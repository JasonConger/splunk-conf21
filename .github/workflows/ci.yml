name: CI
on:
  push:
    branches:
      - "main"
      - "develop"
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"
  pull_request:
    branches:
      - "main"
      - "develop"
  repository_dispatch:
  
jobs:

  # Run linters to help validate source code
  lint:
    name: Lint Code Base
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Lint Code Base
        uses: github/super-linter@v4
        env:
          VALIDATE_ALL_CODEBASE: false
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
  # Semgrep detects and prevents bugs and anti-patterns in your codebase
  semgrep:
    name: Semgrep Scan
    runs-on: ubuntu-latest
    # Skip any PR created by dependabot to avoid permission issues
    if: (github.actor != 'dependabot[bot]')
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Semgrep scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/r2c
  
  build:
    # Build, package, inspect, and upload artifacts
    name: Build
    #needs:
    #  - lint
    #  - semgrep
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          # semantic-release won't trigger a tagged build if this is not set false
          persist-credentials: false
      
      # Our add-on contains Python code, so we need to install Python in the container
      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.7
      
      # Install any dev Python requirements
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements_dev.txt ]; then pip install -r requirements_dev.txt; fi
          
      
      # The cycjimmy/semantic-release-action runs semantic-release (https://github.com/semantic-release/semantic-release)
      # semantic-release uses the commit messages to determine the type of changes in the codebase and determines a release version
      - name: Get Semantic Release Version
        id: semantic-release
        if: github.event_name != 'pull_request'
        uses: cycjimmy/semantic-release-action@v2.5.4
        with:
          semantic_version: 17
          dry_run: true
          extra_plugins: |
            @semantic-release/exec
            @semantic-release/git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Get the Splunk package version based on the semantic-release result
      - name: Determine the Splunk app version to build
        id: splunk-app-build-version
        uses: splunk/addonfactory-get-splunk-package-version-action@v1
        with:
          SemVer: 'v${{ steps.semantic-release.outputs.new_release_version }}'
          PrNumber: ${{ github.event.number }}
      
      # Build the package with UCC generator
      - name: Build Splunk Package
        id: uccgen
        uses: splunk/addonfactory-ucc-generator-action@v1
        with:
          version: ${{ steps.splunk-app-build-version.outputs.VERSION }}
      
      - name: Package Splunk App with SLIM
        id: slim
        uses: splunk/addonfactory-packaging-toolkit-action@v1
        with:
          source: ${{ steps.uccgen.outputs.OUTPUT }}
      
      - name: Upload SLIM raw package as an artifact
        uses: actions/upload-artifact@v2
        with:
          name: package-raw
          path: ${{ steps.uccgen.outputs.OUTPUT }}**
        if: always()
        
      - name: Upload SLIM splunkbase package as an artifact
        uses: actions/upload-artifact@v2
        with:
          name: package-splunkbase
          path: ${{ steps.slim.outputs.OUTPUT }}
        if: always()
      
      - name: Upload SLIM parts as an artifact
        uses: actions/upload-artifact@v2
        with:
          name: package-deployment
          path: build/package/deployment**
        if: always()
  
  # Run AppInspect CLI
  appinspect-cli:
    name: AppInspect CLI
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tags:
          - "cloud"
          - "appapproval"
          - "deprecated_feature"
          - "developer_guidance"
          - "future"
          - "self-service"
          - "splunk_appinspect"
    steps:
      - uses: actions/download-artifact@v2
        with:
          name: package-splunkbase
          path: build/package/

      - name: Run AppInspect CLI
        uses: splunk/appinspect-cli-action@v1
        with:
          app_path: build/package/
          included_tags: ${{ matrix.tags }}
          
  artifact-registry:
    runs-on: ubuntu-latest
    needs:
      - appinspect-cli
      
    steps:
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v2
        with:
          name: package-splunkbase
          path: build/package/splunkbase

      - id: getappid
        run: |
          appid=$(jq -r '.info.id.name' package/app.manifest)
          echo appid=$appid
          echo "::set-output name=result::$(echo $appid)"
      - run: |
          curl -fsSL https://raw.githubusercontent.com/fishworks/gofish/main/scripts/install.sh | bash
          gofish init
          gofish install oras
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      - name: Login to GitHub Packages Docker Registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern=v{{major}}.{{minor}},prefix=${{ steps.getappid.outputs.result }}-
            type=semver,pattern=v{{major}},prefix=${{ steps.getappid.outputs.result }}-
            type=semver,pattern=v{{version}},prefix=${{ steps.getappid.outputs.result }}-
            type=semver,pattern={{major}}.{{minor}},prefix=${{ steps.getappid.outputs.result }}-
            type=semver,pattern={{major}},prefix=${{ steps.getappid.outputs.result }}-
            type=semver,pattern={{version}},prefix=${{ steps.getappid.outputs.result }}-
            type=ref,event=branch,prefix=${{ steps.getappid.outputs.result }}-
            type=ref,event=pr,prefix=${{ steps.getappid.outputs.result }}-
            type=sha,prefix=${{ steps.getappid.outputs.result }}-
            type=sha,format=long,prefix=${{ steps.getappid.outputs.result }}-
      - name: Upload artifacts
        run: |
          tee /tmp/tags &>/dev/null <<EOF
          ${{ steps.meta.outputs.tags }}
          EOF
          pushd build/package/splunkbase/
          PACKAGE=$(ls *)
          echo $PACKAGE
          mv $PACKAGE ${{ steps.getappid.outputs.result }}.spl
          while IFS= read -r line
          do 
            echo ">>$line<<"
            oras push \
                --manifest-config /dev/null:application/vnd.splunk.ent.package.v1.tar+gzip \
                $line \
                ${{ steps.getappid.outputs.result }}.spl
            echo "  complete"
          done < /tmp/tags
          popd
      - name: Output artifact locator
        id: artifactid
        run: |
          echo "::set-output name=result::$(echo ${{ fromJSON(steps.meta.outputs.json).tags[0] }})"
          
    outputs:
      artifact: ${{ steps.artifactid.outputs.result }}
